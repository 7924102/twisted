<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Logging with twisted.python.logger</title>
  </head>

  <body>
    <h1>Logging with twisted.python.logger</h1>

    <h2>The Basics</h2>

    <p>
        Logging consists of two main endpoints: applications that emit events, and observers that receive and handle those events.
        An event is simply an object containing the relevant data that describes something interesting that has occurred in the application.
        For example: a web server might emit an event after handling each request that includes the URI of requested resource, the response's status code, a count of bytes transferred, and so on.
        All of that information might be contained in a pair of objects representing the request and response, so logging this event could be as simple as:
    </p>

    <pre class="python">
log.info(request=request, response=response)
    </pre>

    <p>
        The above API would seem confusing to users of many logging systems, which are built around the idea of emitting strings to a file.
        There is, after all, no string in the above call.
        In such systems, one might expect the API to look like this instead:
    </p>

    <pre class="python">
log.info(
    "{uri}: status={status}, bytes={size}, etc..."
    .format(uri=request.uri, status=response.code, size=response.size)
)
    </pre>

    <p>
        Here, a string is rendered by formatting data from our request and response objects.
        The string can be easily appended to a log file, to be later read by an administrator, or perhaps teased out via some scripts or log gathering tools.
    </p>

    <p>
        One disadvantage to this is that a strings meant to be human-readable are not necessarily easy (or even possibly) for software to handle reliably.
        While text files are a common medium for storing logs, one might want to write code that notices certain types of events and does something other than store the event.
    </p>

    <p>
        In the web server example, if many requests from a given IP address are resulting in failed authentication, someone might be trying to break in to the server.
        Perhaps blocking requests from that IP address would be useful.
        An observer receiving the above event as a string would have to resort to parsing the string to extract the relevant information, which may perform poorly and, depending on how well events are formatted, it may also be difficult to avoid bugs.
        Additionally, any information not encoded into the string is simply unavailable; if the IP address isn't in the string, it cannot be obtained from the event.
    </p>

    <p>
        However, if the <code class="python">request</code> and <code class="python">response</code> objects are available to the observer, as in the first example, it would be possible to write an observer that accessed any attributes of those objects.
        It would also be a lot easier to write an observer that emitted structured information by serializing these objects into a format such as JSON, rows in a database, etc.
    </p>

    <p>
        Events-as-string do have the advantage that it's obvious what an observer that writes strings, for example to a file, would emit.
        We can solve this more flexibly by providing an optional format string in events that can be used for this purpose:
    </p>

    <pre class="python">
log.info(
    "{request.uri}: status={response.status}, bytes={response.size}, etc...",
    request=request, response=response
)
    </pre>

    <p>
        Note that this looks very much like the event-as-strings version of the API, except that the string is not rendered by the caller; we leave that to the observer, <em>if and when it is needed</em>.  The observer also have direct access to the request and response objects, as well as their attributes.
        Now a text-based observer can format the text in a prescribed way, and an observer that wants to handle these events specially can do so.
    </p>


    <h2>Usage for emitting applications</h2>

    <p>
        The first thing that an application that emits logging events need to do is to instantiate a <code class="API" base="twisted.python.logger">Logger</code> object, which provides the API to emit events.
        A <code class="API" base="twisted.python.logger">Logger</code> is often created globally for each module:
    </p>

    <pre class="python">
from twisted.python.logger import Logger
log = Logger()

def handleData(data):
    log.debug("Got data: {data!r}.", data=data)
    </pre>

    <p>
        A <code class="API" base="twisted.python.logger">Logger</code> can also be associated with a class:
    </p>

    <pre class="python">
from twisted.python.logger import Logger

class Foo(object):
    log = Logger()

    def oops(self, data):
        self.log.error(
            "Oops! Invalid data from server: {data!r}",
            data=data
        )
    </pre>

    <p>
        When associated with a class in this manner, the <code>"log_source"</code> key is set in the event, and available for the format string to retrieve values from.  For example:
    </p>

    <a href="listings/logger/logsource.py" class="py-listing">logsource.py</a>

    <p>
        This example will show the string "object with value 7 doing a task" because the <code>log_source</code> key is automatically set to the <code>MyObject</code> instance that the <code>Logger</code> is retrieved from.
    </p>

    <h3>Namespaces</h3>

    <p>
        All <code class="API" base="twisted.python.logger">Logger</code>s have a namespace, which can be used to categorize events.
        Namespaces may be specified by passing in a <code class="python">namespace</code> argument to <code class="API" base="twisted.python.logger">Logger</code>'s initializer, but if none is given, the logger will derive its own namespace by using the module name of the callable that instantiated it, or, in the case of a class, by using the fully qualified name of the class.
        A <code class="API" base="twisted.python.logger">Logger</code> will add a <code class="python">log_namespace</code> key to the events it emits.
    </p>

    <p>
        In the first example above, the namespace would be <code class="python">some.module</code>, and in the second example, it would be <code class="python">some.module.Foo</code>.
    </p>

    <h3>Log levels</h3>

    <p>
        <code class="API" base="twisted.python.logger">Logger</code>s provide a number of methods for emitting events.
        These methods all have the same signature, but each will attach a specific <code class="python">log_level</code> key to events.
        Log levels are defined by the <code class="API" base="twisted.python.logger">LogLevel</code> constants container.
        These are:
    </p>

    <dl>
        <dt><code class="API" base="twisted.python.logger.LogLevel">debug</code></dt>
        <dd>
            Debugging events: Information of use to a developer of the software, not generally of interest to someone running the software unless they are attempting to diagnose a software issue.
        </dd>

        <dt><code class="API" base="twisted.python.logger.LogLevel">info</code></dt>
        <dd>
            Informational events: Routine information about the status of an application, such as incoming connections, startup of a subsystem, etc.
        </dd>

        <dt><code class="API" base="twisted.python.logger.LogLevel">warn</code></dt>
        <dd>
            Warning events: Events that may require greater attention than informational events but are not a systemic failure condition, such as authorization failures, bad data from a network client, etc.
            Such events are of potential interest to system administrators, and should ideally be phrased in such a way, or documented, so as to indicate an action that an administrator might take to mitigate the warning.
        </dd>

        <dt><code class="API" base="twisted.python.logger.LogLevel">error</code></dt>
        <dd>
            Error conditions: Events indicating a systemic failure, such as programming errors in the form of unhandled exceptions, loss of connectivity to an external system without which no useful work can proceed, such as a database or API endpoint, or resource exhaustion.
            Similarly to warnings, errors that are related to operational parameters may be actionable to system administrators and should provide references to resources which an administrator might use to resolve them.
        </dd>

        <dt><code class="API" base="twisted.python.logger.LogLevel">critical</code></dt>
        <dd>
          Critical failures: Errors indicating systemic failure (ie. service outage), data corruption, imminent data loss, etc. which must be handled immediately.  This includes errors unanticipated by the software, such as unhandled exceptions, wherein the cause and consequences are unknown.
        </dd>
    </dl>

    <p>
        In the first example above, the call to <code class="python">log.debug</code> will add a <code class="python">log_level</code> key to the emitted event with a value of <code class="API" base="twisted.python.logger">LogLevel.debug</code>.
        In the second example, calling <code class="python">self.log.error</code> would use a value of <code class="API" base="twisted.python.logger">LogLevel.error</code>.
    </p>

    <p>
        The above descriptions are simply guidance, but it is worth noting that log levels have a reduced value if they are used inconsistantly.
        If one module in an application considers a message informational, and another module considers a similar message an error, then filtering based on log levels becomes harder.
        This is increasingly likely if the modules in question are developed by different parties, as will often be the case with externally source libraries and frameworks.
        (If a module tends to use higher levels than another, namespaces may be used to calibrate the relative use of log levels, but that is obviously suboptimal.)
        Sticking to the above guidelines will hopefully help here.
    </p>

    <h3>Emitter method signatures</h3>

    <p>
        The emitter methods (<code class="API" base="twisted.python.logger.Logger">debug</code>, <code class="API" base="twisted.python.logger.Logger">info</code>, <code class="API" base="twisted.python.logger.Logger">warn</code>, etc.) all take an optional format string as a first argument, followed by keyword arguments that will be included in the emitted event.
    </p>

    <p>
        Note that all three examples in the opening section of this HOWTO fit this signature.  The first omits the format, which doesn't lend itself well to text logging.  The second omits the keyword arguments, which hostile to anything other than text logging, and is therefore ill-advised.  Finally, the third provides both.
    </p>

    <h3>Format strings</h3>

    <p>
        Format strings provide observers with a standard way to format an event as text, via the function <code class="API" base="twisted.python.logger">formatEvent</code>.
        Format strings should be <code class="python">unicode</code> or UTF-8-encoded <code class="python">bytes</code>, and use <a href="http://www.python.org/dev/peps/pep-3101/">PEP 3101</a> syntax to describe how the event should be rendered as text.
        There are two variations from PEP 3101 in the format strings used by this module:
    </p>

    <ol>
        <li>
            Positional (numerical) field names (eg. <code class="python">{0}</code>) are not permitted.
            Because event keys are provided via keyword arguments, and the logging system adds additional keys, the order of event attributes is non-deterministic, which means positional field names do not make sense in this context.
        </li>
        <li>
            Field names ending in parentheses (eg. <code class="python">{foo()}</code>) will call the referenced object with no arguments, then call <code class="python">str</code> on the result, rather than calling <code class="python">str</code> on the referenced object directly.
            This extension to PEP 3101 format syntax is provided to make it as easy as possible to defer potentially expensive work until a log message must be emitted.
            For example, let's say that we wanted to log a message with some useful, but potentially expensive information from the 'request' object:
            <pre class="python">
log.info("{request.uri} useful, but expensive: {request.usefulButExpensive()}",
         request=request)
            </pre>
            In the case where this log message is filtered out as uninteresting and not saved, no formatting work is done <i>at all</i>; and since we can use PEP3101 attribute-access syntax in conjunction with this parenthesis extension, the caller does not even need to build a function or bound method object to pass as a separate key.
            There is no support for specifying arguments in the format string; the goal is to make it idiomatic to express that work be done later, not to implement a full Python expression evaluator.
        </li>
    </ol>

    <h2>Saving events for later</h2>

    <p>
        For compatibility reasons, <code>twistd</code> will log to a text-based format by default.
        However, it's much better to use a structured log file format which preserves information about the events being logged.
        <code>twisted.python.logger</code> provides APIs: <code class="API" base="twisted.python.logger">jsonFileLogObserver</code> <code class="API" base="twisted.python.logger">eventsFromJSONLogFile</code> which allow you to save and retrieve structured log events with a basic level of fidelity.
        Log events are serialized as JSON dictionaries, with as lenient serialization rules as possible; any unknown values are replaced with simple placeholder values.
    </p>

    <p>
        <code>jsonFileLogObserver</code> will create a log observer that will save events as structured data, like so:
    </p>

    <a href="listings/logger/saver.py" class="py-listing">saver.py</a>

    <p>
        And <code>eventsFromJSONLogFile</code> can load those events again; here, you can see that the event has preserved enough information to be formatted as human-readable again:
    </p>

    <a href="listings/logger/loader.py" class="py-listing">loader.py</a>

    <p>
        You can also, of course, feel free to access any of the keys in the <code>event</code> object as you load them, as well; basic structures such as lists, numbers, dictionaries and strings (anything serializable with JSON) will be preserved:
    </p>

    <a href="listings/logger/loader-math.py" class="py-listing">loader-math.py</a>

    <!-- TODO: command-line option for twistd to do this -->

    <h2>Implementing an observer</h2>

    <p>
        An observer must provide the <code class="API" base="twisted.python.logger">ILogObserver</code> interface.  That interface simply describes a 1-argument callable that takes a <code>dict</code>, so a simple implementation may simply use the handy <code class="API" base="zope.interface">provider</code> decorator on a function that takes one argument:
    </p>

    <pre class="python">
from zope.interface import provider
from twisted.python.logger import ILogObserver, formatEvent

@provider(ILogObserver)
def simpleObserver(event):
    print(formatEvent(event))
    </pre>

    <p>
        The <code class="API" base="twisted.python.logger">formatEvent</code> function returns a textual (<code class="python">unicode</code>) representation of the event.
    </p>

    <p>
        While it is recommended, in most cases it is not required that observers declare their compliance with <code class="API" base="twisted.python.logger">ILogObserver</code>.
        This flexibility exists to allow for pre-existing callables and lambda expressions to be used as observers.
        As an example, if one would like to accumulate events in a <code class="python">list</code>, then <code class="python">list.append</code> may be used as an observer.
    </p>

    <p>
        When implementing your own log observer, however, you should always keep in mind that unlike most objects within Twisted, a log observer <i>must be thread safe</i>.
    </p>

    <p>
        Specifically, a log observer:
        <ul>
            <li>must be prepared to be called from threads other than the main thread (or I/O thread, or reactor thread)</li>
            <li>must be prepared to be called from multiple threads concurrently</li>
            <li>must not interact with other Twisted APIs that are not explicitly thread-safe without first taking precautions like using <code class="API" base="twisted.internet.interfaces.IReactorThreads">callFromThread</code></li>
        </ul>
    </p>

    <p>
        Keep in mind that this is true even if you elect not to explicitly interact with any threads from your program.
        Twisted itself may log messages from threads, and Twisted may internally use APIs like <code class="API" base="twisted.internet.interfaces.IReactorThreads">callInThread</code>; for example, Twisted uses threads to look up hostnames when making an outgoing connection.
    </p>

    <p>
        Given this extra wrinkle, it's usually best to see if you can find an existing log observer implementation that does what you need before implementing your own; thread safety can be tricky to implement.
        Luckily, <code class="API">twisted.python.logging</code> comes with several useful observers, which are documented below.
    </p>

    <h3>Writing an observer for event analysis</h3>

    <p>
        Twisted includes log observers which take care of most of the "normal" uses of logging, like writing messages to a file, saving them as text, filtering them, and so on.
        There are two common reasons you might want to write a log observer of your own.
        The first is to ship log messages over to a different kind of external system which Twisted itself does not support.
        If you've read the above, you now know enough to do that; simply implement a function that converts the dictionary to something amenable to your external system or file format, and send it there or save it.
        The second task is to do some kind of analysis, either real-time within your process or after the fact offline.
    </p>

    <p>
        You're probably going to have to aggregate information from your own code and from libraries you're using, including Twisted itself, and you may not have much in the way of control over how those messages are organized.
        You're also probably trying to aggregate information from ad-hoc messages into some kind of structure.
    </p>

    <p>
        One way to extract such semi-structured information is to feed your logs into an external system like <a href="http://logstash.net">logstash</a>, and process them there.
        Such systems are quite powerful and <code>twisted.python.logger</code> does not try to replace them.
        However, such systems are necessarily external, and therefore if you want to react to the log analysis <em>within</em> your application - for example, denying access in response to an abusive client - you would have to write some glue code to push messages from your log-analysis system back into your application.
        For such cases, it's useful to be able to write log analysis code as a log observer.
    </p>

    <p>
        Assuming that the libraries whose log events you're interested in analyzing are making use of <code>twisted.python.logger</code>, you can analyze log events either live as they're being logged, or loaded from a saved log file.
    </p>

    <p>
        If you're writing code to log messages directly for potential analysis, then you should simply structure your messages to include all necessary information as serialization-friendly values of log keys, and then simply pull them out, like the <code>loader-math.py</code> example above.
    </p>

    <p>
        However, let's say you're trying to interact with a system that logs messages like so:
    </p>

    

    <h2>Registering an observer</h2>

    <p>
        One way to register an observer is to contruct a <code class="API" base="twisted.python.logger">Logger</code> object with it:
    </p>

    <pre class="python">
from twisted.python.logger import Logger
from myobservers import PrintingObserver

log = Logger(observer=PrintingObserver())

log.info("Hello")
    </pre>

    <p>
        This will cause all of a logger's events to be sent to the given observer.  In the above example, all events emitted by the logger (eg. <code class="python">"Hello"</code>) will be printed.
        While that is useful in some cases, it is common to register multiple observers, and to do so globally for all (or most) loggers in an application.
    </p>

    <h2>The global log publisher</h2>

    <p>
        When a <code class="API" base="twisted.python.logger">Logger</code> is created without giving it an observer, it will send its events to the global log publisher, which is a singleton accessible via the name <code class="API" base="twisted.python.logger">globalLogPublisher</code>.
    </p>

    <p>
        The global log publisher is an instance of a private subclass of <code class="API" base="twisted.python.logger">LogPublisher</code>, which is itself an <code class="API" base="twisted.python.logger">ILogObserver</code>.  What this means is that the global log publisher accepts events like any other observer, and that it forwards those events to other observers.  Observers can be registered to be forwarded events by calling the <code class="API" base="twisted.python.logger">LogPublisher</code> method <code class="API" base="twisted.python.logger.LogPublisher">addObserver</code>, and unregister by calling <code class="API" base="twisted.python.logger.LogPublisher">removeObserver</code>:
    </p>

    <pre class="python">
from twisted.python.logger import globalLogPublisher
from myobservers import PrintingObserver

log = Logger()

globalLogPublisher.addObserver(PrintingObserver())

log.info("Hello")
    </pre>

    <p>
        The result here is the same as the previous example, except that addtional observers can be (and may already have been) registered.  We know that <code class="python">"Hello"</code> will be printed.  We don't know, but it's very possible, that the same event will also be handled by other observers.
    </p>

    <p>
        There is no supported API to discover what other observers are registered with a <code class="API" base="twisted.python.logger">LogPublisher</code>; in general, one doesn't need to know.  If an application is running in <code>twistd</code>, for example, it's likely that an observer is streaming events to a file by the time the application code is in play.  If it is running in a <code>twistd</code> web container, there will probably be another observer writing to the access log.
    </p>

    <p>
        A caveat here is that events are <code class="python">dict</code> objects, which are mutable, so it is possible for an observer to modify an event that it sees.
        Because doing so will modify what other observers will see, modifying a received event can be problematic and should be strongly discouraged.
        It can be particularly dangerous to edit or remove the content of an existing event key.
    </p>

    <h3>Starting the global log publisher</h3>

    <p>
        When the global log publisher is created, it uses a <code class="API" base="twisted.python.logger">LimitedHistoryLogObserver</code> (see below) to store events that are logged by the application in memory until logging is started.
        Logging is started by registering the first set of observers with the global log publisher by calling <code class="API" base="twisted.python.logger.globalLogPublisher">startLoggingWithObservers</code>:
    </p>

    <pre class="python">
from twisted.python.logger import globalLogPublisher
from myobservers import PrintingObserver

log = Logger()

log.info("Hello")

observers = [PrintingObserver()]

globalLogPublisher.startLoggingWithObservers(observers)

log.info("Hello, again")
    </pre>

    <p>
        What this does is add the given observers (in this example, the <code class="python">PrintingObserver</code>) with the global log observer, then forwards all of the events that were stored in memory prior to calling <code class="API" base="twisted.python.logger.globalLogPublisher">startLoggingWithObservers</code> to these observers, and gets rid of the <code class="API" base="twisted.python.logger">LimitedHistoryLogObserver</code>, as it is no longer needed.
        It is an error to call <code class="API" base="twisted.python.logger.globalLogPublisher">startLoggingWithObservers</code> more than once.
    </p>


    <h2>Provided log observers</h2>

    <p>
        This module provides a number of pre-built observers for applications to use:
    </p>

    <dl>
        <dt><code class="API" base="twisted.python.logger">LogPublisher</code></dt>
        <dd>
            Forwards events to other publishers.
            This allows one to create a graph of observers.
        </dd>

        <dt><code class="API" base="twisted.python.logger">LimitedHistoryLogObserver</code></dt>
        <dd>
            Stores a limited number of received events, and can re-play those stored events to another observer later.
            This is useful for keeping recent logging history in memory for inspection when other log outputs are not available.
        </dd>

        <dt><code class="API" base="twisted.python.logger">FileLogObserver</code></dt>
        <dd>
            Formats events as text, prefixed with a time stamp and a "system identifier", and writes them to a file.
            The system identifier defaults to a combination of the event's namespace and level.
        </dd>

        <dt><code class="API" base="twisted.python.logger">FilteringLogObserver</code></dt>
        <dd>
            Forwards events to another observer after applying a set of filter predicates.
            <code class="API" base="twisted.python.logger">LogLevelFilterPredicate</code> is a predicate that be configured to keep track of which log levels to filter for different namespaces, and will filter out events that are not at the appropriate level or higher.
        </dd>

    </dl>


    <h2>Compatibility with standard library logging</h2>

    <p>
        <code class="API" base="twisted.python.logger">STDLibLogObserver</code> is provided for compatibility with the standard library's <code class="API" base="">logging</code> module.
        Log levels are mapped between the two systems, and the various attributes of standard library log records are filled in properly.
    </p>

    <p>
        Note that standard library logging is a blocking API, and logging can be configured to block for long periods (eg. it may write to the network).
        No protection is provided to prevent blocking, so such configurations may cause Twisted applications to perform poorly.
    </p>


    <h2>Compatibility with twisted.python.log</h2>

    <p>
        This module provides some facilities to enable the existing <code class="API" base="">twisted.python.log</code> module to compatibly forward it's messages to this module.
        As such, existing clients of <code class="API" base="">twisted.python.log</code> will begin using this module indirectly, with no changes to the older module's API.
    </p>


    <h3>Incrementally porting emitters</h3>

    <p>
        Applications that wish to switch from the old module to the new module without having to change much code may do so my using the <code class="API" base="twisted.python.logger">LegacyLogger</code> class, which exposes an API that is largely compatible with many uses of the <code class="API" base="">twisted.python.log</code> module.  For example, this code:
    </p>

    <pre class="python">
from twisted.python import log

log.msg("blah")

log.msg(warning=message, category=reflect.qual(category),
        filename=filename, lineno=lineno,
        format="%(filename)s:%(lineno)s: %(category)s: %(warning)s")

try:
    1/0
except Exception as e:
    log.err(e, "Math is hard")
    </pre>


    <p>
        &ellip; could be modified thusly to stop depending on the older module by simply changing the import line and instantiating a <code class="API" base="twisted.python.logger">LegacyLogger</code>.
        The rest of the code stays the same:
    </p>

    <pre class="python">
from twisted.python.logger import LegacyLogger
log = LegacyLogger()

log.msg("blah")

log.msg(warning=message, category=reflect.qual(category),
        filename=filename, lineno=lineno,
        format="%(filename)s:%(lineno)s: %(category)s: %(warning)s")

try:
    1/0
except Exception as e:
    log.err(e, "Math is hard")
    </pre>

    <p>
        Because the older module is forwarding to the new module, this is probably only useful if Twisted were to deprecate the older module one needs to port large application to the new module incrementally.
    </p>


    <h3>Incrementally porting observers</h3>

    <p>
        Observers also have an incremental path for porting to the new module.  <code class="API" base="twisted.python.logger">LegacyLogObserverWrapper</code> is an <code class="API" base="twisted.python.logger">ILogObserver</code> that wraps a log observer written for the older module.
        This allows an old-style observer to be registered with a new-style logger or log publisher compatibly.
    </p>

  </body>
</html>
